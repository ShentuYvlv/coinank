import React, { useState, useEffect, useRef } from 'react'
import { 
  Box, 
  Card, 
  CardContent, 
  CardHeader,
  Typography, 
  useTheme,
  FormControl,
  Select,
  MenuItem,
  Slider,
  IconButton
} from '@mui/material'
import { ZoomOutMap as ZoomOutIcon } from '@mui/icons-material'
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js'
import { Line } from 'react-chartjs-2'
import { useStore } from '../../store/useStore'
import axios from 'axios'
import { oichartCache } from '../../utils/chartCache'
import { queuedRequest } from '../../utils/requestQueue'
import { useSharedData } from '../../hooks/useSharedData'

ChartJS.register(
  CategoryScale,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
  Legend
)

const OpenInterestChart = () => {
  const theme = useTheme()
  const { currentToken } = useStore()
  const { setOpenInterestData } = useSharedData()
  const abortControllerRef = useRef(null)

  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const [interval, setInterval] = useState('1h')
  const [dataType, setDataType] = useState('USD')
  const [timeRangeStart, setTimeRangeStart] = useState(0)
  const [timeRangeEnd, setTimeRangeEnd] = useState(100)
  
  // Êó∂Èó¥Âë®ÊúüÈÄâÈ°π
  const intervalOptions = [
    { value: '5m', label: '5ÂàÜÈíü' },
    { value: '15m', label: '15ÂàÜÈíü' },
    { value: '30m', label: '30ÂàÜÈíü' },
    { value: '1h', label: '1Â∞èÊó∂' },
    { value: '4h', label: '4Â∞èÊó∂' },
    { value: '12h', label: '12Â∞èÊó∂' },
    { value: '1d', label: '1Â§©' }
  ]
  
  // Êï∞ÊçÆÁ±ªÂûãÈÄâÈ°π
  const typeOptions = [
    { value: 'USD', label: 'USD' },
    { value: 'BTC', label: 'BTC' },
    { value: 'ETH', label: 'ETH' }
  ]
  
  // Ëé∑ÂèñÂêàÁ∫¶ÊåÅ‰ªìÈáèÊï∞ÊçÆ
  const fetchOpenInterestData = async () => {
    if (!currentToken) return

    // ÂèñÊ∂à‰πãÂâçÁöÑËØ∑Ê±Ç
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
    }

    // ÂàõÂª∫Êñ∞ÁöÑAbortController
    abortControllerRef.current = new AbortController()

    // ÊûÑÂª∫ÁºìÂ≠òÈîÆ
    const cacheKey = `${currentToken}_${interval}_${dataType}`
    console.log('üîç Ê£ÄÊü•OpenInterestChartÁºìÂ≠òÈîÆ:', cacheKey)

    // Ê£ÄÊü•ÁºìÂ≠ò
    const cachedData = oichartCache.get(cacheKey)
    if (cachedData) {
      console.log('üíæ ‰ΩøÁî®OpenInterestChartÁºìÂ≠òÊï∞ÊçÆ')
      setData(cachedData)
      setLoading(false)
      setError(null)
      // Âç≥‰Ωø‰ΩøÁî®ÁºìÂ≠òÔºå‰πüË¶ÅÊõ¥Êñ∞ÂÖ®Â±ÄÂÖ±‰∫´Êï∞ÊçÆ
      setOpenInterestData(cachedData)
      return
    }

    setLoading(true)
    setError(null)

    try {
      console.log('üåê ÂèëÈÄÅOpenInterestChartËØ∑Ê±Ç:', `/api/openinterest/${currentToken}`)

      // ‰ΩøÁî®ËØ∑Ê±ÇÈòüÂàóÔºå‰∏≠Á≠â‰ºòÂÖàÁ∫ß
      const response = await queuedRequest(
        () => axios.get(`/api/openinterest/${currentToken}`, {
          params: {
            interval,
            type: dataType
          },
          signal: abortControllerRef.current.signal
        }),
        6 // ‰∏≠Á≠â‰ºòÂÖàÁ∫ß
      )

      // Ê£ÄÊü•ËØ∑Ê±ÇÊòØÂê¶Ë¢´ÂèñÊ∂à
      if (abortControllerRef.current.signal.aborted) {
        return
      }

      if (response.data && response.data.success) {
        // ÁºìÂ≠òÊï∞ÊçÆ
        oichartCache.set(cacheKey, response.data.data)
        setData(response.data.data)

        // Êõ¥Êñ∞ÂÖ®Â±ÄÂÖ±‰∫´Êï∞ÊçÆ
        setOpenInterestData(response.data.data)
      } else {
        throw new Error(response.data?.error || 'Êï∞ÊçÆËé∑ÂèñÂ§±Ë¥•')
      }
    } catch (err) {
      // ÂøΩÁï•ÂèñÊ∂àÁöÑËØ∑Ê±Ç
      if (err.name === 'AbortError') {
        console.log('OpenInterestËØ∑Ê±ÇË¢´ÂèñÊ∂à:', err.message)
        return
      }

      console.error('Failed to fetch open interest data:', err)
      if (err.response) {
        // ÊúçÂä°Âô®ËøîÂõû‰∫ÜÈîôËØØÂìçÂ∫î
        let errorMessage = `HTTP ${err.response.status}`
        if (err.response.data) {
          if (typeof err.response.data === 'string') {
            errorMessage += `: ${err.response.data}`
          } else if (typeof err.response.data === 'object') {
            errorMessage += `:\n${JSON.stringify(err.response.data, null, 2)}`
          }
        } else {
          errorMessage += `: ${err.response.statusText}`
        }
        setError(errorMessage)
      } else if (err.request) {
        // ËØ∑Ê±ÇÂèëÂá∫‰ΩÜÊ≤°ÊúâÊî∂Âà∞ÂìçÂ∫î
        setError('ÁΩëÁªúÈîôËØØ: Êó†Ê≥ïËøûÊé•Âà∞ÊúçÂä°Âô®')
      } else {
        // ÂÖ∂‰ªñÈîôËØØ
        setError(`ËØ∑Ê±ÇÈîôËØØ: ${err.message}`)
      }
    } finally {
      setLoading(false)
    }
  }
  
  // ÁªÑ‰ª∂ÊåÇËΩΩÂíåÂèÇÊï∞ÂèòÂåñÊó∂Ëé∑ÂèñÊï∞ÊçÆÔºåÊ∑ªÂä†Èò≤Êäñ
  useEffect(() => {
    if (currentToken) {
      // Ê∑ªÂä†Áü≠ÊöÇÂª∂ËøüÔºåÈÅøÂÖçÂú®‰ª£Â∏ÅÂàáÊç¢ËøáÁ®ã‰∏≠ÂèëÈÄÅÊóßtokenÁöÑËØ∑Ê±Ç
      const timer = setTimeout(() => {
        fetchOpenInterestData()
      }, 50)

      return () => clearTimeout(timer)
    }
  }, [interval, dataType, currentToken])

  // ÁªÑ‰ª∂Âç∏ËΩΩÊó∂Ê∏ÖÁêÜ
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }
  }, [])
  
  // Â§ÑÁêÜÂõæË°®Êï∞ÊçÆ
  const chartData = React.useMemo(() => {
    if (!data || !data.data) return null

    const oiData = data.data
    const timestamps = oiData.tss || []
    const values = oiData.values || []

    if (timestamps.length === 0) return null

    // Ê†πÊçÆÊó∂Èó¥ËåÉÂõ¥ËøáÊª§Êï∞ÊçÆ
    const totalDataPoints = timestamps.length
    const startIndex = Math.floor(totalDataPoints * timeRangeStart / 100)
    const endIndex = Math.ceil(totalDataPoints * timeRangeEnd / 100)
    
    const filteredTimestamps = timestamps.slice(startIndex, endIndex)
    const filteredValues = values.slice(startIndex, endIndex)

    const labels = filteredTimestamps.map(ts => {
      const date = new Date(ts)
      return date.toLocaleDateString('zh-CN', {
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      })
    })

    return {
      labels,
      datasets: [
        {
          label: `ÂêàÁ∫¶ÊåÅ‰ªìÈáè (${dataType})`,
          data: filteredValues,
          borderColor: theme.palette.primary.main,
          backgroundColor: theme.palette.primary.main + '20',
          borderWidth: 2,
          fill: true,
          tension: 0.1,
          pointRadius: 1,
          pointHoverRadius: 4,
        },
      ],
    }
  }, [data, timeRangeStart, timeRangeEnd, theme, dataType])
  
  const options = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'top',
        labels: {
          color: theme.palette.text.primary,
          font: {
            size: 12,
          },
        },
      },
      tooltip: {
        callbacks: {
          label: (context) => {
            let label = context.dataset.label || ''
            if (label) {
              label += ': '
            }
            if (context.parsed.y !== null) {
              const value = context.parsed.y
              if (dataType === 'USD') {
                label += new Intl.NumberFormat('zh-CN', {
                  style: 'currency',
                  currency: 'USD',
                  minimumFractionDigits: 0,
                  maximumFractionDigits: 0,
                }).format(value)
              } else {
                label += value.toFixed(4) + ' ' + dataType
              }
            }
            return label
          },
        },
      },
    },
    scales: {
      x: {
        grid: {
          color: 'rgba(255, 255, 255, 0.1)',
        },
        ticks: {
          color: theme.palette.text.secondary,
          font: {
            size: 11,
          },
        },
      },
      y: {
        grid: {
          color: 'rgba(255, 255, 255, 0.1)',
        },
        ticks: {
          color: theme.palette.text.secondary,
          font: {
            size: 11,
          },
          callback: function(value) {
            if (dataType === 'USD') {
              return new Intl.NumberFormat('zh-CN', {
                style: 'currency',
                currency: 'USD',
                notation: 'compact',
                maximumFractionDigits: 1,
              }).format(value)
            } else {
              return value.toFixed(4) + ' ' + dataType
            }
          },
        },
      },
    },
  }
  
  if (loading) {
    return (
      <Card sx={{ height: '100%' }}>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            ÂêàÁ∫¶ÊåÅ‰ªìÈáè
          </Typography>
          <Box sx={{ 
            height: 300, 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center' 
          }}>
            <Typography color="text.secondary">
              Âä†ËΩΩ‰∏≠...
            </Typography>
          </Box>
        </CardContent>
      </Card>
    )
  }

  if (error || !chartData) {
    return (
      <Card sx={{ height: '100%' }}>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            ÂêàÁ∫¶ÊåÅ‰ªìÈáè
          </Typography>
          <Box sx={{ 
            height: 300, 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center' 
          }}>
            <Typography color="text.secondary">
              {error || 'ÊöÇÊó†Êï∞ÊçÆ'}
            </Typography>
          </Box>
        </CardContent>
      </Card>
    )
  }

  return (
    <Card sx={{ height: '100%' }}>
      <CardHeader
        title={
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
            {/* Left side dropdowns */}
            <Box sx={{ display: 'flex', gap: 1 }}>
              <FormControl size="small">
                <Select
                  value={interval}
                  onChange={(e) => setInterval(e.target.value)}
                  sx={{ minWidth: 80 }}
                >
                  {intervalOptions.map(option => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>

              <FormControl size="small">
                <Select
                  value={dataType}
                  onChange={(e) => setDataType(e.target.value)}
                  sx={{ minWidth: 60 }}
                >
                  {typeOptions.map(option => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Box>

            {/* Center title */}
            <Typography variant="h6" sx={{ flex: 1, textAlign: 'center' }}>
              ÂêàÁ∫¶ÊåÅ‰ªìÈáè - {currentToken}
            </Typography>

            {/* Right side controls */}
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              {/* ÂèØ‰ª•Ê∑ªÂä†ÂÖ∂‰ªñÊéßÂà∂ÊåâÈíÆ */}
            </Box>
          </Box>
        }
        action={
          <IconButton size="small" onClick={() => fetchOpenInterestData()}>
            <ZoomOutIcon />
          </IconButton>
        }
      />
      <Box sx={{ px: 2, pb: 1 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          <Typography variant="caption">Êó∂Èó¥Âë®Êúü:</Typography>
          <Box sx={{ flex: 1, mx: 2 }}>
            <Slider
              value={[timeRangeStart, timeRangeEnd]}
              onChange={(e, newValue) => {
                setTimeRangeStart(newValue[0])
                setTimeRangeEnd(newValue[1])
              }}
              valueLabelDisplay="auto"
              valueLabelFormat={(value) => `${value}%`}
              sx={{ 
                '& .MuiSlider-thumb': {
                  width: 16,
                  height: 16,
                }
              }}
            />
          </Box>
          <Typography variant="caption" sx={{ minWidth: 100, textAlign: 'center' }}>
            {timeRangeStart === 0 && timeRangeEnd === 100 ? 'ÊòæÁ§∫ÂÖ®ÈÉ®' : `${timeRangeStart}%-${timeRangeEnd}%`}
          </Typography>
        </Box>
      </Box>
      <CardContent sx={{ height: 400, p: 1 }}>
        <Line data={chartData} options={options} />
      </CardContent>
    </Card>
  )
}

export default OpenInterestChart
