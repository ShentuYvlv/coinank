import React, { useState, useEffect, useRef } from 'react'
import {
  Box,
  Card,
  CardContent,
  CardHeader,
  Typography,
  FormControl,
  Select,
  MenuItem,
  Slider,
  Button,
  ButtonGroup,
  Alert,
  Skeleton,
  CircularProgress,
  IconButton
} from '@mui/material'
import { Refresh as RefreshIcon } from '@mui/icons-material'
import * as echarts from 'echarts'
import axios from 'axios'
import { useStore } from '../../store/useStore'
import { queuedRequest } from '../../utils/requestQueue'
import { useSharedData } from '../../hooks/useSharedData'

// ‰∫§ÊòìÊâÄÈ¢úËâ≤ÈÖçÁΩÆ
const EXCHANGE_COLORS = {
  'Binance': '#F3BA2F',
  'Okex': '#FF4444',
  'Bitmex': '#0088CC',
  'Bybit': '#00C851',
  'Bitget': '#0066FF',
  'Gate': '#00DDDD',
  'Huobi': '#FF8800',
  'dYdX': '#00DD88',
  'Hyperliquid': '#FFDD00',
  'Bitunix': '#DD00DD'
}

// Êó∂Èó¥Èó¥ÈöîÈÄâÈ°π
const INTERVAL_OPTIONS = [
  { value: '5m', label: '5ÂàÜÈíü' },

  { value: '8H', label: '8Â∞èÊó∂' },
]

function FundingRateChart() {
  const { currentToken } = useStore()
  const { setFundingRateData } = useSharedData()
  const chartRef = useRef(null)
  const chartInstance = useRef(null)

  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [interval, setInterval] = useState('5m')
  const [timeRangeStart, setTimeRangeStart] = useState(50)
  const [timeRangeEnd, setTimeRangeEnd] = useState(100)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const [priceData, setPriceData] = useState([])
  const [fundingData, setFundingData] = useState([])
  const [exchanges, setExchanges] = useState([])
  
  // ÊéßÂà∂ÊòæÁ§∫ÁöÑÊï∞ÊçÆÁ≥ªÂàó
  const [showPrice, setShowPrice] = useState(true)
  const [visibleExchanges, setVisibleExchanges] = useState({})
  
  // YËΩ¥ÊãñÊãΩÁº©ÊîæÁä∂ÊÄÅ
  const isDraggingRef = useRef(false)
  const dragStartRef = useRef({ y: 0, yAxisMin: [0, 0], yAxisMax: [1, 1] })
  const mousePosition = useRef({ x: 0, y: 0 })

  // Ëé∑ÂèñËµÑÈáëË¥πÁéáÊï∞ÊçÆ
  const fetchData = async () => {
    if (!currentToken) return

    setLoading(true)
    setError(null)

    try {
      console.log('üîÑ ÂºÄÂßãËé∑ÂèñËµÑÈáëË¥πÁéáÊï∞ÊçÆ...')
      console.log('üìã ËØ∑Ê±ÇÂèÇÊï∞:', {
        token: currentToken,
        interval
      })

      const requestUrl = `/api/fundingrate/${currentToken}`
      const requestParams = {
        interval
      }

      console.log('üåê ÂèëÈÄÅFundingRateËØ∑Ê±Ç:', requestUrl, requestParams)

      // ‰ΩøÁî®ËØ∑Ê±ÇÈòüÂàóÔºå‰∏≠Á≠â‰ºòÂÖàÁ∫ß
      const response = await queuedRequest(
        () => axios.get(requestUrl, { params: requestParams }),
        4 // ‰∏≠Á≠âÂÅè‰Ωé‰ºòÂÖàÁ∫ß
      )

      const data = response.data

      console.log('üì° FundingRate API ÂÆåÊï¥ÂìçÂ∫î:', data)

      if (data.success && data.data) {
        const { priceData, fundingData, warnings } = data.data

        console.log('üìä Â§ÑÁêÜËµÑÈáëË¥πÁéáÂõæË°®Êï∞ÊçÆ:', priceData)
        console.log('üìä Â§ÑÁêÜËµÑÈáëË¥πÁéáÂéÜÂè≤Êï∞ÊçÆ:', fundingData)
        
        // Â§ÑÁêÜË≠¶Âëä‰ø°ÊÅØ
        if (warnings && warnings.length > 0) {
          console.log('‚ö†Ô∏è APIË≠¶Âëä:', warnings)
          // ÂèØ‰ª•ÈÄâÊã©ÊòæÁ§∫Ë≠¶ÂëäÁªôÁî®Êà∑ÔºåÁõÆÂâçÂÖàËÆ∞ÂΩïÂà∞ÊéßÂà∂Âè∞
        }

        // ËÆæÁΩÆ‰ª∑Ê†ºÊï∞ÊçÆ
        if (priceData && priceData.chartData && priceData.chartData.length > 0) {
          setPriceData(priceData.chartData)
          setExchanges(priceData.exchanges || [])

          // ÂàùÂßãÂåñ‰∫§ÊòìÊâÄÂèØËßÅÊÄß
          const initialVisibility = {}
          priceData.exchanges?.forEach(exchange => {
            initialVisibility[exchange] = true
          })
          setVisibleExchanges(initialVisibility)
          
          console.log('‚úÖ ÂõæË°®Êï∞ÊçÆËÆæÁΩÆÂÆåÊàê:', {
            chartDataLength: priceData.chartData?.length,
            exchanges: priceData.exchanges
          })
        } else {
          console.log('‚ö†Ô∏è ËµÑÈáëË¥πÁéáÂõæË°®Êï∞ÊçÆ‰∏∫Á©∫')
          setPriceData([])
          setExchanges([])
          setVisibleExchanges({})
        }

        // ËÆæÁΩÆËµÑÈáëË¥πÁéáÊï∞ÊçÆ
        setFundingData(fundingData || [])

        // Êõ¥Êñ∞ÂÖ®Â±ÄÂÖ±‰∫´Êï∞ÊçÆ
        setFundingRateData(fundingData || [])

        console.log('‚úÖ ËµÑÈáëË¥πÁéáÊï∞ÊçÆËé∑ÂèñÊàêÂäü')
      } else {
        console.error('API response failed:', data)
        throw new Error(data?.error || 'Êï∞ÊçÆËé∑ÂèñÂ§±Ë¥•')
      }
    } catch (err) {
      console.error('Failed to fetch funding rate data:', err)
      setError(`Âä†ËΩΩÊï∞ÊçÆÂ§±Ë¥•: ${err.message}`)
    } finally {
      setLoading(false)
    }
  }

  // Â§ÑÁêÜÊï∞ÊçÆÂπ∂ÂàõÂª∫ÂõæË°®
  const createChart = () => {
    if (!chartRef.current || !priceData.length) return

    // ÈîÄÊØÅÁé∞ÊúâÂõæË°®
    if (chartInstance.current) {
      chartInstance.current.dispose()
    }

    // ÂàõÂª∫Êñ∞ÂõæË°®
    chartInstance.current = echarts.init(chartRef.current, 'dark')

    // Â§ÑÁêÜ‰ª∑Ê†ºÊï∞ÊçÆ
    const processedPriceData = priceData.map(item => [
      parseInt(item[0]), // Êó∂Èó¥Êà≥
      parseFloat(item[1]) || null // ‰ª∑Ê†º
    ]).filter(item => item[1] !== null)

    // Â§ÑÁêÜËµÑÈáëË¥πÁéáÊï∞ÊçÆ - Êåâ‰∫§ÊòìÊâÄÂàÜÁªÑ
    const fundingSeriesData = {}
    exchanges.forEach((exchange, index) => {
      fundingSeriesData[exchange] = priceData.map(item => [
        parseInt(item[0]), // Êó∂Èó¥Êà≥
        parseFloat(item[index + 2]) || null // ËµÑÈáëË¥πÁéá (Ë∑≥ËøáÊó∂Èó¥Êà≥Âíå‰ª∑Ê†º)
      ]).filter(item => item[1] !== null)
    })

    // ‰∏çÂÜçËøõË°åÊï∞ÊçÆËøáÊª§ÔºåËÆ©EChartsÁöÑdataZoomÊù•Â§ÑÁêÜÊó∂Èó¥ËåÉÂõ¥
    const filteredPriceData = processedPriceData
    const filteredFundingData = fundingSeriesData

    // ÊûÑÂª∫ÂõæË°®Á≥ªÂàó
    const series = []

    // ‰ª∑Ê†ºÁ≥ªÂàó (Âè≥YËΩ¥)
    if (showPrice && filteredPriceData.length > 0) {
      series.push({
        name: `${currentToken} ‰ª∑Ê†º`,
        type: 'line',
        yAxisIndex: 1,
        data: filteredPriceData,
        lineStyle: {
          color: '#FFA500',
          width: 2
        },
        symbol: 'none',
        smooth: false
      })
    }

    // ËµÑÈáëË¥πÁéáÁ≥ªÂàó (Â∑¶YËΩ¥)
    Object.keys(filteredFundingData).forEach(exchange => {
      if (visibleExchanges[exchange] && filteredFundingData[exchange].length > 0) {
        series.push({
          name: exchange,
          type: 'line',
          yAxisIndex: 0,
          data: filteredFundingData[exchange],
          lineStyle: {
            color: EXCHANGE_COLORS[exchange] || '#666',
            width: 1.5
          },
          symbol: 'none',
          smooth: false
        })
      }
    })

    // ÂõæË°®ÈÖçÁΩÆ
    const option = {
      backgroundColor: 'transparent',
      grid: {
        left: '1%',
        right: '1%',
        bottom: '8%',
        top: '8%',
        containLabel: true
      },
      tooltip: {
        trigger: 'axis',
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        borderColor: '#333',
        textStyle: { color: '#fff' },
        formatter: function(params) {
          if (!params || params.length === 0) return ''
          
          const time = new Date(params[0].value[0]).toLocaleString('zh-CN')
          let content = `<div style="margin-bottom: 5px; font-weight: bold;">${time}</div>`
          
          params.forEach(param => {
            const value = param.value[1]
            if (param.seriesName.includes('‰ª∑Ê†º')) {
              content += `<div style="color: ${param.color};">‚óè ${param.seriesName}: $${value.toFixed(4)}</div>`
            } else {
              content += `<div style="color: ${param.color};">‚óè ${param.seriesName}: ${(value * 100).toFixed(4)}%</div>`
            }
          })
          
          return content
        }
      },
      legend: {
        show: false
      },
      xAxis: {
        type: 'time',
        axisLine: { lineStyle: { color: '#333' } },
        axisTick: { lineStyle: { color: '#333' } },
        axisLabel: { 
          color: '#999',
          formatter: function(value) {
            const date = new Date(value)
            const now = new Date()
            const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24))
            
            if (diffDays === 0) {
              return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' })
            } else if (diffDays < 7) {
              return date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' })
            } else {
              return date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' })
            }
          }
        },
        splitLine: { show: false }
      },
      yAxis: [
        {
          type: 'value',
          name: 'ËµÑÈáëË¥πÁéá',
          position: 'left',
          scale: true, // ÂêØÁî®Ëá™Âä®Áº©Êîæ
          min: function(value) {
            // Âä®ÊÄÅËÆ°ÁÆóÊúÄÂ∞èÂÄºÔºåÁ°Æ‰øùÊúâÂêàÁêÜÁöÑËæπË∑ù
            const range = value.max - value.min
            const margin = Math.max(range * 0.1, Math.abs(value.min) * 0.05)
            return value.min - margin
          },
          max: function(value) {
            // Âä®ÊÄÅËÆ°ÁÆóÊúÄÂ§ßÂÄºÔºåÁ°Æ‰øùÊúâÂêàÁêÜÁöÑËæπË∑ù
            const range = value.max - value.min
            const margin = Math.max(range * 0.1, Math.abs(value.max) * 0.05)
            return value.max + margin
          },
          boundaryGap: [0, 0], // ÁßªÈô§ËæπÁïåÈó¥Èöô
          axisLine: { lineStyle: { color: '#333' } },
          axisTick: { lineStyle: { color: '#333' } },
          axisLabel: {
            color: '#999',
            formatter: function(value) {
              return `${(value * 100).toFixed(3)}%`
            }
          },
          splitLine: {
            lineStyle: { color: '#333', type: 'dashed' }
          }
        },
        {
          type: 'value',
          name: '‰ª∑Ê†º (USD)',
          position: 'right',
          scale: true, // ÂêØÁî®Ëá™Âä®Áº©Êîæ
          min: function(value) {
            // ‰ª∑Ê†ºËΩ¥Âä®ÊÄÅËÆ°ÁÆóÊúÄÂ∞èÂÄºÔºåÁ°Æ‰øùÊúâÂêàÁêÜÁöÑËæπË∑ù
            const range = value.max - value.min
            const margin = Math.max(range * 0.05, value.min * 0.02)
            return Math.max(0, value.min - margin) // ‰ª∑Ê†º‰∏çËÉΩ‰∏∫Ë¥ü
          },
          max: function(value) {
            // ‰ª∑Ê†ºËΩ¥Âä®ÊÄÅËÆ°ÁÆóÊúÄÂ§ßÂÄºÔºåÁ°Æ‰øùÊúâÂêàÁêÜÁöÑËæπË∑ù
            const range = value.max - value.min
            const margin = Math.max(range * 0.05, value.max * 0.02)
            return value.max + margin
          },
          boundaryGap: [0, 0], // ÁßªÈô§ËæπÁïåÈó¥Èöô
          axisLine: { lineStyle: { color: '#333' } },
          axisTick: { lineStyle: { color: '#333' } },
          axisLabel: {
            color: '#999',
            formatter: function(value) {
              return `$${value.toFixed(4)}`
            }
          },
          splitLine: { show: false }
        }
      ],
      series: series,
      dataZoom: [
        {
          type: 'inside',
          xAxisIndex: 0,
          filterMode: 'none',
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: false,
          preventDefaultMouseMove: false,
          start: timeRangeStart,
          end: timeRangeEnd
        }
      ]
    }

    chartInstance.current.setOption(option)
    
    // Ê∑ªÂä†YËΩ¥ÊãñÊãΩÁº©ÊîæÂäüËÉΩ
    chartInstance.current.off('mousedown')
    chartInstance.current.off('mousemove') 
    chartInstance.current.off('mouseup')
    
    chartInstance.current.on('mousedown', (params) => {
      const event = params.event?.event
      if (!event) return
      
      // Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáªÂú®YËΩ¥Âå∫Âüü
      const chartDom = chartInstance.current.getDom()
      const rect = chartDom.getBoundingClientRect()
      const x = event.clientX - rect.left
      const width = rect.width
      
      // Â∑¶‰æßYËΩ¥Âå∫Âüü (0-80px) ÊàñÂè≥‰æßYËΩ¥Âå∫Âüü (width-80 - width)
      if (x < 80 || x > width - 80) {
        isDraggingRef.current = true
        const option = chartInstance.current.getOption()
        
        // Ëé∑ÂèñÂΩìÂâçYËΩ¥ÁöÑÂÆûÈôÖÊï∞ÂÄºËåÉÂõ¥
        const yAxis0 = option.yAxis[0]
        const yAxis1 = option.yAxis[1]
        
        dragStartRef.current = {
          y: event.clientY,
          yAxisMin: [
            typeof yAxis0.min === 'number' ? yAxis0.min : null,
            typeof yAxis1.min === 'number' ? yAxis1.min : null
          ],
          yAxisMax: [
            typeof yAxis0.max === 'number' ? yAxis0.max : null,
            typeof yAxis1.max === 'number' ? yAxis1.max : null
          ]
        }
        event.preventDefault()
        event.stopPropagation()
      }
    })
  }

  // ÂàáÊç¢ÂõæË°®Á≥ªÂàóÊòæÁ§∫/ÈöêËóèÔºà‰∏çÈáçÊñ∞ÁªòÂà∂ÂõæË°®Ôºâ
  const toggleSeriesVisibility = (seriesName, isVisible) => {
    if (!chartInstance.current) return
    
    if (seriesName === 'price') {
      setShowPrice(isVisible)
      // Êü•Êâæ‰ª∑Ê†ºÁ≥ªÂàóÂπ∂ÂàáÊç¢ÊòæÁ§∫Áä∂ÊÄÅ
      chartInstance.current.dispatchAction({
        type: isVisible ? 'legendSelect' : 'legendUnSelect',
        name: `${currentToken} ‰ª∑Ê†º`
      })
    } else {
      // Â§ÑÁêÜ‰∫§ÊòìÊâÄÁ≥ªÂàó
      setVisibleExchanges(prev => ({
        ...prev,
        [seriesName]: isVisible
      }))
      
      // ÂàáÊç¢‰∫§ÊòìÊâÄÁ≥ªÂàóÊòæÁ§∫Áä∂ÊÄÅ
      chartInstance.current.dispatchAction({
        type: isVisible ? 'legendSelect' : 'legendUnSelect',
        name: seriesName
      })
    }
  }

  // ÁõëÂê¨Êï∞ÊçÆÂèòÂåñÔºåÈáçÊñ∞ÂàõÂª∫ÂõæË°®ÔºàÁßªÈô§timeRangeStartÂíåtimeRangeEnd‰æùËµñÔºâ
  useEffect(() => {
    createChart()
  }, [priceData, fundingData, currentToken])

  // ÁõëÂê¨Êó∂Èó¥ËåÉÂõ¥ÂèòÂåñÔºåÊõ¥Êñ∞dataZoomËÄå‰∏çÈáçÊñ∞ÁªòÂà∂ÂõæË°®
  useEffect(() => {
    if (chartInstance.current && priceData.length > 0) {
      chartInstance.current.setOption({
        dataZoom: [
          {
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'none',
            zoomOnMouseWheel: true,
            moveOnMouseMove: true,
            moveOnMouseWheel: false,
            preventDefaultMouseMove: false,
            start: timeRangeStart,
            end: timeRangeEnd
          }
        ]
      })
    }
  }, [timeRangeStart, timeRangeEnd])

  // ÁõëÂê¨‰ª£Â∏ÅÂèòÂåñÔºåÊ∑ªÂä†Èò≤Êäñ
  useEffect(() => {
    if (currentToken) {
      // Ê∑ªÂä†Áü≠ÊöÇÂª∂ËøüÔºåÈÅøÂÖçÂú®‰ª£Â∏ÅÂàáÊç¢ËøáÁ®ã‰∏≠ÂèëÈÄÅÊóßtokenÁöÑËØ∑Ê±Ç
      const timer = setTimeout(() => {
        fetchData()
      }, 50)

      return () => clearTimeout(timer)
    }
  }, [currentToken, interval])

  // ÁªÑ‰ª∂Âç∏ËΩΩÊó∂ÈîÄÊØÅÂõæË°®
  useEffect(() => {
    return () => {
      if (chartInstance.current) {
        chartInstance.current.dispose()
      }
    }
  }, [])

  // Â§ÑÁêÜÁ™óÂè£Â§ßÂ∞èÂèòÂåñÂíåÂÖ®Â±ÄÈº†Ê†á‰∫ã‰ª∂
  useEffect(() => {
    const handleResize = () => {
      if (chartInstance.current) {
        chartInstance.current.resize()
      }
    }

    const handleGlobalMouseUp = () => {
      isDraggingRef.current = false
    }

    const handleGlobalMouseMove = (event) => {
      mousePosition.current = { x: event.clientX, y: event.clientY }
      
      // Â§ÑÁêÜYËΩ¥ÊãñÊãΩÁº©Êîæ
      if (isDraggingRef.current && chartInstance.current) {
        const deltaY = event.clientY - dragStartRef.current.y
        const scaleFactor = 1 + (deltaY * 0.005) // Áº©ÊîæÁ≥ªÊï∞ÔºåË∞ÉÂ∞è‰∏Ä‰∫õ‰ΩøÂÖ∂Êõ¥Âπ≥Êªë
        
        if (scaleFactor > 0.1 && scaleFactor < 10) { // ÈôêÂà∂Áº©ÊîæËåÉÂõ¥
          const option = chartInstance.current.getOption()
          const yAxis0 = option.yAxis[0]
          const yAxis1 = option.yAxis[1]
          
          // ËÆ°ÁÆóÊñ∞ÁöÑYËΩ¥ËåÉÂõ¥
          const newMin0 = dragStartRef.current.yAxisMin[0] !== null 
            ? dragStartRef.current.yAxisMin[0] / scaleFactor 
            : 'dataMin'
          const newMax0 = dragStartRef.current.yAxisMax[0] !== null 
            ? dragStartRef.current.yAxisMax[0] / scaleFactor 
            : 'dataMax'
          const newMin1 = dragStartRef.current.yAxisMin[1] !== null 
            ? dragStartRef.current.yAxisMin[1] / scaleFactor 
            : 'dataMin'
          const newMax1 = dragStartRef.current.yAxisMax[1] !== null 
            ? dragStartRef.current.yAxisMax[1] / scaleFactor 
            : 'dataMax'
          
          const newOption = {
            yAxis: [
              {
                ...yAxis0,
                min: newMin0,
                max: newMax0
              },
              {
                ...yAxis1,
                min: newMin1,
                max: newMax1
              }
            ]
          }
          
          chartInstance.current.setOption(newOption, false)
        }
        
        event.preventDefault()
      }
    }

    window.addEventListener('resize', handleResize)
    window.addEventListener('mouseup', handleGlobalMouseUp)
    window.addEventListener('mousemove', handleGlobalMouseMove)
    
    return () => {
      window.removeEventListener('resize', handleResize)
      window.removeEventListener('mouseup', handleGlobalMouseUp)
      window.removeEventListener('mousemove', handleGlobalMouseMove)
    }
  }, [])

  return (
    <Card>
      <CardHeader
        title={
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
            {/* Left side controls */}
            <Box sx={{ display: 'flex', gap: 1 }}>
              <FormControl size="small">
                <Select
                  value={interval}
                  onChange={(e) => setInterval(e.target.value)}
                  sx={{ minWidth: 100 }}
                >
                  {INTERVAL_OPTIONS.map(option => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Box>

            {/* Center title */}
            <Typography variant="h6" sx={{ flex: 1, textAlign: 'center' }}>
              ËµÑÈáëË¥πÁéáÂéÜÂè≤ÂõæË°® - {currentToken}
            </Typography>

            {/* Right side placeholder */}
            <Box sx={{ width: 120 }} />
          </Box>
        }
        action={
          <IconButton size="small" onClick={() => fetchData()}>
            <RefreshIcon />
          </IconButton>
        }
        sx={{ pb: 1 }}
      />

      <CardContent sx={{ pt: 0 }}>
        {/* ÊéßÂà∂ÊåâÈíÆÁªÑ */}
        <Box sx={{ mb: 2, display: 'flex', gap: 1, flexWrap: 'wrap', alignItems: 'center' }}>
        {/* ‰ª∑Ê†ºÊòæÁ§∫ÊéßÂà∂ */}
        <Button
          size="small"
          variant={showPrice ? "contained" : "outlined"}
          onClick={() => toggleSeriesVisibility('price', !showPrice)}
          sx={{ 
            color: showPrice ? 'white' : '#FFA500',
            backgroundColor: showPrice ? '#FFA500' : 'transparent',
            borderColor: '#FFA500',
            '&:hover': {
              backgroundColor: showPrice ? '#FF8C00' : 'rgba(255, 165, 0, 0.1)'
            }
          }}
        >
          {currentToken} ‰ª∑Ê†º
        </Button>

        {/* ‰∫§ÊòìÊâÄÊòæÁ§∫ÊéßÂà∂ */}
        {exchanges.map(exchange => (
          <Button
            key={exchange}
            size="small"
            variant={visibleExchanges[exchange] ? "contained" : "outlined"}
            onClick={() => toggleSeriesVisibility(exchange, !visibleExchanges[exchange])}
            sx={{ 
              color: visibleExchanges[exchange] ? 'white' : EXCHANGE_COLORS[exchange],
              backgroundColor: visibleExchanges[exchange] ? EXCHANGE_COLORS[exchange] : 'transparent',
              borderColor: EXCHANGE_COLORS[exchange],
              '&:hover': {
                backgroundColor: visibleExchanges[exchange] 
                  ? EXCHANGE_COLORS[exchange] 
                  : `${EXCHANGE_COLORS[exchange]}20`
              }
            }}
          >
            {exchange}
          </Button>
        ))}
      </Box>

        {/* Êó∂Èó¥ÊªëÂùó */}
        <Box sx={{ mb: -1, px: 2 }}>
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
            <Typography variant="caption" color="text.secondary">
              Êó∂Èó¥ËåÉÂõ¥:
            </Typography>
            <Typography variant="caption" color="text.secondary">
              {timeRangeStart === 0 && timeRangeEnd === 100 ? 'ÊòæÁ§∫ÂÖ®ÈÉ®' : `${timeRangeStart}%-${timeRangeEnd}%`}
            </Typography>
          </Box>
          <Slider
            value={[timeRangeStart, timeRangeEnd]}
            onChange={(_, newValue) => {
              setTimeRangeStart(newValue[0])
              setTimeRangeEnd(newValue[1])
            }}
            valueLabelDisplay="auto"
            valueLabelFormat={(value) => `${value}%`}
            sx={{
              '& .MuiSlider-thumb': {
                width: 16,
                height: 16,
              }
            }}
          />
        </Box>
      </CardContent>
      
      <CardContent sx={{ height: 450, p: 1 }}>
        <Box sx={{ position: 'relative', height: '100%' }}>
          {loading && (
            <Box
              sx={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                zIndex: 10
              }}
            >
              <CircularProgress />
            </Box>
          )}
          
          {error && (
            <Box
              sx={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                height: '100%'
              }}
            >
              <Typography color="error">{error}</Typography>
            </Box>
          )}

          {!loading && !error && (!priceData || priceData.length === 0) && (
            <Box
              sx={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                height: '100%'
              }}
            >
              <Typography color="text.secondary">
                {currentToken} ÊöÇÊó†ËµÑÈáëË¥πÁéáÊï∞ÊçÆÔºåÂèØËÉΩËØ•‰ª£Â∏Å‰∏çÊîØÊåÅËµÑÈáëË¥πÁéáÊü•ËØ¢ÊàñÊï∞ÊçÆÊöÇÊú™Êõ¥Êñ∞
              </Typography>
            </Box>
          )}
          
          {!loading && !error && priceData && priceData.length > 0 && (
            <div
              ref={chartRef}
              style={{
                width: '100%',
                height: '100%'
              }}
            />
          )}
      </Box>
    </CardContent>
    </Card>
  )
}

export default FundingRateChart
